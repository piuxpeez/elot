<html>
<head>
<link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">

<script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
<style>

.card{height:200px;
width:300px;
margin:150px auto;
}

.red{background:red;}

.blue{background:blue;}

.green{background:green;}


</style>
</head>

<body>






<div class="card red" data-aos="fade-up"></div>

 id="demo">This might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.

Thankfully requestAnimationFrame solves these issues. It’s a method that we can use to repeatedly check our page to see if elements are visible, while making sure we don’t overload the browser by checking thousands of times per second. It does this by limiting how often the callback is executed to either the screen’s refresh rate or 60 times per second.
 
60 times per second might sound like a lot but for the work we’ll be doing it’s very slow and won’t overload the browser.
</div>

<div id="j">
To set up ourThis might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.

Thankfully requestAnimationFrame solves these issues. It’s a method that we can use to repeatedly check our page to see if elements are visible, while making sure we don’t overload the browser by checking thousands of times per second. It does this by limiting how often the callback is executed to either the screen’s refresh rate or 60 times per second.
⅔
60 times per second might  like a lot but for the work we’ll be doing it’s very slow and won’t overload the browser.
</div>To set up ourThis might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.

Thankfully requestAnimationFrame solves these issues. It’s a method that we can use to repeatedly check our page to see if elements are visible, while making sure we don’t overload the browser by checking thousands of times per second. It does this by limiting how often the callback is executed to either the screen’s refresh rate or 60 times per second.
⅔
60 times per second might  like a lot but for the work we’ll be doing it’s very slow and won’t overload the browser.
</div>
To set up ourTTo set up ourThis might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.

<div class="card blue" data-aos="fade-up"></div>

 id="demo">This might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.

Thankfully requestAnimationFrame solves these issues. It’s a method that we can use to repeatedly check our page to see if elements are visible, while making sure we don’t overload the browser by checking thousands of times per second. It does this by limiting how often the callback is executed to either the screen’s refresh rate or 60 times per second.
 
60 times per second might sound like a lot but for the work we’ll be doing it’s very slow and won’t overload the browser.
</div>

<div id="j">
To set up ourThis might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.

Thankfully requestAnimationFrame solves these issues. It’s a method that we can use to repeatedly check our page to see if elements are visible, while making sure we don’t overload the browser by checking thousands of times per second. It does this by limiting how often the callback is executed to either the screen’s refresh rate or 60 times per second.
⅔
60 times per second might  like a lot but for the work we’ll be doing it’s very slow and won’t overload the browser.
</div>To set up ourThis might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.

Thankfully requestAnimationFrame solves these issues. It’s a method that we can use to repeatedly check our page to see if elements are visible, while making sure we don’t overload the browser by checking thousands of times per second. It does this by limiting how often the callback is executed to either the screen’s refresh rate or 60 times per second.
⅔
60 times per second might  like a lot but for the work we’ll be doing it’s very slow and won’t overload the browser.
</div>
To set up ourTTo set up ourThis might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.




<div class="card green" data-aos="fade-up"></div>

 id="demo">This might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.

Thankfully requestAnimationFrame solves these issues. It’s a method that we can use to repeatedly check our page to see if elements are visible, while making sure we don’t overload the browser by checking thousands of times per second. It does this by limiting how often the callback is executed to either the screen’s refresh rate or 60 times per second.
 
60 times per second might sound like a lot but for the work we’ll be doing it’s very slow and won’t overload the browser.
</div>

<div id="j">
To set up ourThis might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.

Thankfully requestAnimationFrame solves these issues. It’s a method that we can use to repeatedly check our page to see if elements are visible, while making sure we don’t overload the browser by checking thousands of times per second. It does this by limiting how often the callback is executed to either the screen’s refresh rate or 60 times per second.
⅔
60 times per second might  like a lot but for the work we’ll be doing it’s very slow and won’t overload the browser.
</div>To set up ourThis might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.

Thankfully requestAnimationFrame solves these issues. It’s a method that we can use to repeatedly check our page to see if elements are visible, while making sure we don’t overload the browser by checking thousands of times per second. It does this by limiting how often the callback is executed to either the screen’s refresh rate or 60 times per second.
⅔
60 times per second might  like a lot but for the work we’ll be doing it’s very slow and won’t overload the browser.
</div>
To set up ourTTo set up ourThis might work in some ways, but sadly this has a couple of big problems. The first being efficiency. When scrolling, the console.log here will fire like crazy. If we’re doing anything like parsing the DOM tree or other heavy tasks, this will add a lot of overhead to the browser. It could very easily slow things down and make our animations janky.

A second issue is iOS. Scrolling on some phones only results in this scroll trigger being fired after the scrolling has finished. We’d like this to work on mobile, so that’s a big fail there.


<div class="card blue" data-aos="fade-up"></div>


<script>

AOS.init();

</script>


</body>
